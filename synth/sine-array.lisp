;;; 
;;; array-ugens.lisp
;;;
;;;
;;;
;;; **********************************************************************
;;; Copyright (c) 2022 Orm Finnendahl <orm.finnendahl@selma.hfmdk-frankfurt.de>
;;;
;;; Revision history: See git repository.
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Gnu Public License, version 2 or
;;; later. See https://www.gnu.org/licenses/gpl-2.0.html for the text
;;; of this agreement.
;;; 
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;;; GNU General Public License for more details.
;;;
;;; **********************************************************************

(in-package :incudine)

(declaim (inline %phasor-n))
(define-vug %phasor-n ((phase-array (simple-array sample *))
                       (n integer) rate end)
  (prog1 (sample (aref phase-array n))
    (incf (aref phase-array n) rate)
    (cond ((>= (aref phase-array n) end) (decf (aref phase-array n) end))
          ((minusp (aref phase-array n)) (incf (aref phase-array n) end)))))

(declaim (inline phasor-n))
(define-vug phasor-n ((phase-array (simple-array sample *))
                         (n integer) freq)
     "Produce a normalized moving phase value with frequency FREQ and
initial value INIT (0 by default).
phase-array is an array of phase values, n indexes into it."
     (:defaults (make-array 1 :element-type 'sample :initial-contents '(0.0d0)) 1 0)
     (with-samples ((rate (* freq *sample-duration*)))
       (%phasor-n phase-array n rate 1)))

(declaim (inline sine-n))
(define-vug sine-n ((n integer) (phase-array (simple-array sample *)) freq amp
                    (sin-phase-array (simple-array sample *)))
  "High precision sine wave oscillator with frequency FREQ, amplitude
AMP being the nth element of an array of sines with phase array PHASE-ARRAY."
  (:defaults (make-array 1 :element-type 'sample :initial-contents '(0.0d0))
             1 440 1
             (make-array 1 :element-type 'sample :initial-contents '(0.0d0)))
  (* amp (sin (+ (* +twopi+ (phasor-n (the (simple-array sample *) phase-array) n freq)) (aref sin-phase-array n)))))

(dsp! test3 ((freq-array (simple-array sample *))
             (amp-array (simple-array sample *)))
  (:defaults (make-array 2 :element-type 'sample :initial-contents '(440.0d0 880.0d0))
             (make-array 2 :element-type 'sample :initial-contents '(0.05d0 0.03d0)))
  (with ((out 0.0d0)
         (init-n (init-only (format t "~%init-n: ~a~%" (length freq-array)) (length freq-array)))
         (phase-array (init-only (make-array init-n :element-type 'sample :initial-element 0.0d0)))
         (sine-phase-array (init-only (make-array init-n :element-type 'sample :initial-element 0.0d0))))
    (declare (type sample out)
             (type (array sample *) phase-array sine-phase-array))
    (setf out 0.0d0)
    (loop
      for n below init-n
      do (incf out (sine-n n phase-array (aref freq-array n) (aref amp-array n) sine-phase-array)))
    (stereo out)))

(declaim (inline interpolate-n))
(define-vug-macro interpolate-n (idx generator-form freqs
                                   &optional (interpolation :linear) initial-value-p)
     "Interpolation of the values generated by a performance-time GENERATOR-FORM.

The values of the generator are calculated with a modulable frequency FREQ.

INTERPOLATION is one of :LINEAR, :COS, :CUBIC or NIL (default).

If INTERPOLATION is :CUBIC and INITIAL-VALUE-P is T, three adjacent
points are initialized with the same value.

"
     (destructuring-bind (bindings init update ergebnis)
         (case interpolation
           ((:lin :linear)
            `(((x0s (make-array (length freqs) :element-type 'sample :initial-element 0.0d0))
               (x1s (make-array (length freqs) :element-type 'sample :initial-element 0.0d0)))
              (setf (aref x1s n) input)
              (setf (aref x0s n) (aref x1s n) (aref x1s n) (update input) (aref deltas n) (- (aref x0s n) (aref x1s n)))
              (+ (aref x1s n) (* (aref phases n) (aref deltas n)))))
           (:cos
            `(((x0s (make-array (length freqs) :element-type 'sample :initial-element 0.0d0))
               (x1s (make-array (length freqs) :element-type 'sample :initial-element 0.0d0)))
              (setf (aref x1s n) input)
              (setf (aref x0s n) (aref x1s n) (aref x1s n) (update input))
              (cos-interp (aref phases n) (aref x1s n) (aref x0s n))))
           (:cubic
            `(((x0s (make-array (length freqs) :element-type 'sample :initial-element 0.0d0))
               (x1s (make-array (length freqs) :element-type 'sample :initial-element 0.0d0))
               (x2s (make-array (length freqs) :element-type 'sample :initial-element 0.0d0))
               (x3s (make-array (length freqs) :element-type 'sample :initial-element 0.0d0)))
              (setf (aref x1s n) input
                    ;; Three adjacent points initialized with the same
                    ;; value when it is required an initial value.
                    (aref x2s n) ,(if initial-value-p 'input `(update input))
                    (aref x3s n) ,(if initial-value-p 'input `(update input)))
              (setf (aref x0s n) (aref x1s n) (aref x1s n) (aref x2s n) (aref x2s n) (aref x3s n) (aref x3s n) (update input))
              (cubic-interp phase (aref x3s n) (aref x2s n) (aref x1s n) (aref x0s n))))
           (otherwise
            `(((x0s (make-array (length freqs) :element-type 'sample :initial-element 0.0d0)))
              nil (setf (aref x0s n) (update input)) (aref x0s n))))
       (with-gensyms (interp-n)
         `(vuglet ((,interp-n ((n integer) input (freqs (simple-array sample *)))
                              (with ((phases (make-array (length freqs) :element-type 'sample :initial-element 0.0d0))
                                     (deltas (make-array (length freqs) :element-type 'sample :initial-element 0.0d0))
                                     (incs (make-array (length freqs) :element-type 'sample :initial-element 0.0d0))
                                     ,@bindings)
                                (declare (type (simple-array sample *) phases deltas incs ,@(mapcar #'first bindings)))
                                (initialize
                                 (loop
                                   for n below (length freqs)
                                   do (progn
                                        (format t "~&phases: ~a, n: ~a" phases n)
                                        (setf (aref phases n) 0.0d0)
                                        (setf (aref incs n) (* (aref freqs n) *sample-duration*))
                                        ,init)))
                                (decf (aref phases n) (aref incs n))
                                (when (minusp (aref phases n))
                                  (setf (aref phases n) (wrap (aref phases n) 0 1))
                                  ,update)
                                ,ergebnis)))
            (,interp-n ,idx ,generator-form ,freqs)))))

(define-vug randi-n ((n integer) (freqs (simple-array sample *)))
  (interpolate-n n (white-noise) freqs))

(dsp! bl-noise-test-n ((freqs (simple-array sample *)) (bws (simple-array sample *)) (amps (simple-array sample *)))
    (with ((out 0.0d0)
           (init-n (init-only (format t "~%init-n: ~a~%" (length freqs)) (length freqs)))
           (phase-array (init-only (make-array init-n :element-type 'sample :initial-element 0.0d0)))
           (sine-phase-array (init-only (make-array init-n :element-type 'sample :initial-element 0.0d0))))
    (declare (type sample out)
             (type (array sample *) phase-array sine-phase-array))
    (loop
      for n below init-n
      do (progn
;;           (format t "~&n: ~a" n)
           (incf out
                 (* (sine-n n phase-array (aref freqs n) (aref amps n) sine-phase-array)
                    (randi-n n bws)))))
    (stereo out)))

#|
(defparameter *amp-test* (make-array 3 :element-type 'sample :initial-contents '(0.05d0 0.03d0 0.04d0)))

(bl-noise-test-n
 (make-array 3 :element-type 'sample :initial-contents '(440.0d0 790.0d0 1250.0d0))
 (make-array 3 :element-type 'sample :initial-contents '(20.0d0 20.0d0 100.0d0))
 *amp-test*
 :id 1)


(setf (aref *amp-test* 0) 0.03d0)


(test3
 :freq-array (make-array 3 :element-type 'sample :initial-contents '(440.0d0 790.0d0 1250.0d0))
 :amp-array *amp-test*
 :id 1)

(setf (aref *amp-test* 0) 0.03d0)

(set-control 1 :freq-array
             (make-array 3 :element-type 'sample :initial-contents '(450.0d0 890.0d0 1050.0d0)))

(node 1)

(free 1)

(test3
 :freq-array (make-array 3 :element-type 'sample :initial-contents '(440.0d0 790.0d0 1250.0d0))
 :amp-array (make-array 3 :element-type 'sample :initial-contents '(0.05d0 0.03d0 0.04d0)))

(test3 (make-array 3 :element-type 'sample :initial-contents '(440.0d0 660.0d0 1250.0d0))
       (make-array 3 :element-type 'sample :initial-contents '(0.05d0 0.02d0 0.01d0)))


|#


(define-vug randi (freq)
  (interpolate (white-noise) freq))

(dsp! bl-noise-test (freq bw)
  (stereo (* (sine freq 0.1) (randi bw))))

(dsp! bl-noise-test (freq bw amp1 amp2)
  (stereo (* (sine freq amp1) (* amp2 (randi bw)))))

(bl-noise-test 810 200 0.05 1)

(bl-noise-test 810 200 0.1 0.5)


